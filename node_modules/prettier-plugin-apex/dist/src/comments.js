"use strict";
/* eslint no-param-reassign: 0, no-plusplus: 0, no-else-return: 0, consistent-return: 0 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasPrettierIgnore = exports.handleRemainingComment = exports.handleEndOfLineComment = exports.handleOwnLineComment = exports.getTrailingComments = exports.willPrintOwnComments = exports.isBlockComment = exports.canAttachComment = exports.printDanglingComment = exports.printComment = exports.isPrettierIgnore = void 0;
const prettier_1 = __importDefault(require("prettier"));
const util_1 = require("./util");
const { concat, join, lineSuffix, hardline } = prettier_1.default.doc.builders;
const { addDanglingComment, addLeadingComment, addTrailingComment, hasNewlineInRange, skipWhitespace, } = prettier_1.default.util;
const constants = require("./constants");
const apexTypes = constants.APEX_TYPES;
/**
 * Print ApexDoc comment. This is straight from prettier handling of JSDoc
 * @param comment the comment to print.
 */
function printApexDocComment(comment) {
    const lines = comment.value.split("\n");
    return concat([
        join(hardline, lines.map((commentLine, index) => (index > 0 ? " " : "") +
            (index < lines.length - 1
                ? commentLine.trim()
                : commentLine.trimLeft()))),
    ]);
}
function isPrettierIgnore(comment) {
    let content;
    if (comment["@class"] === apexTypes.BLOCK_COMMENT) {
        // For simplicity sake we only support this format
        // /* prettier-ignore */
        content = comment.value
            .trim()
            .substring(2, comment.value.length - 2)
            .trim();
    }
    else {
        content = comment.value.trim().substring(2).trim();
    }
    return content === "prettier-ignore";
}
exports.isPrettierIgnore = isPrettierIgnore;
function printComment(path) {
    // This handles both Inline and Block Comments.
    // We don't just pass through the value because unlike other string literals,
    // this should not be escaped
    const comment = path.getValue();
    let result;
    const node = path.getValue();
    if ((0, util_1.isApexDocComment)(node)) {
        result = printApexDocComment(node);
    }
    else {
        result = node.value;
    }
    if (comment.trailingEmptyLine) {
        result = concat([result, hardline]);
    }
    comment.printed = true;
    return result;
}
exports.printComment = printComment;
function printDanglingComment(commentPath, options) {
    const sourceCode = options.originalText;
    const comment = commentPath.getValue();
    const loc = comment.location;
    const isFirstComment = commentPath.getName() === 0;
    const parts = [];
    let fromPos = skipWhitespace(sourceCode, loc.startIndex - 1, {
        backwards: true,
    });
    if (fromPos === false) {
        return "";
    }
    fromPos += 1;
    const leadingSpace = sourceCode.slice(fromPos, loc.startIndex);
    const numberOfNewLines = isFirstComment
        ? 0
        : (leadingSpace.match(/\n/g) || []).length;
    if (numberOfNewLines > 0) {
        // If the leading space contains newlines, then add at most 2 new lines
        const numberOfNewLinesToInsert = Math.min(numberOfNewLines, 2);
        parts.push(...Array(numberOfNewLinesToInsert).fill(hardline));
    }
    if (comment["@class"] === apexTypes.INLINE_COMMENT) {
        parts.push(lineSuffix(printComment(commentPath)));
    }
    else {
        parts.push(printComment(commentPath));
    }
    comment.printed = true;
    return concat(parts);
}
exports.printDanglingComment = printDanglingComment;
/**
 * This is called by Prettier's comment handling code, in order for Prettier
 * to tell if this is a node to which a comment can be attached.
 *
 * @param node The current node
 * @returns {boolean} whether a comment can be attached to this node or not.
 */
function canAttachComment(node) {
    return (node.loc &&
        node["@class"] &&
        node["@class"] !== apexTypes.INLINE_COMMENT &&
        node["@class"] !== apexTypes.BLOCK_COMMENT);
}
exports.canAttachComment = canAttachComment;
/**
 * This is called by Prettier's comment handling code, in order to find out
 * if this is a block comment.
 *
 * @param comment The current comment node.
 * @returns {boolean} whether it is a block comment.
 */
function isBlockComment(comment) {
    return comment["@class"] === apexTypes.BLOCK_COMMENT;
}
exports.isBlockComment = isBlockComment;
/**
 * This is called by Prettier's comment handling code.
 * We can use this to tell Prettier that we will print comments manually on
 * certain nodes.
 * @returns {boolean} whether or not we will print the comment on this node manually.
 */
function willPrintOwnComments(path) {
    const node = path.getValue();
    return !node || !node["@class"] || node["@class"] === apexTypes.ANNOTATION;
}
exports.willPrintOwnComments = willPrintOwnComments;
function getTrailingComments(node) {
    return node.comments.filter((comment) => comment.trailing);
}
exports.getTrailingComments = getTrailingComments;
function handleDanglingComment(comment) {
    const { enclosingNode } = comment;
    if (enclosingNode &&
        constants.ALLOW_DANGLING_COMMENTS.indexOf(enclosingNode["@class"]) !== -1 &&
        ((enclosingNode.stmnts && enclosingNode.stmnts.length === 0) ||
            (enclosingNode.members && enclosingNode.members.length === 0))) {
        addDanglingComment(enclosingNode, comment, null);
        return true;
    }
    return false;
}
/**
 * Turn the leading comment to a WhereExpression inside a
 * WhereCompoundExpression into a trailing comment to the previous WhereExpression.
 * The reason is that a WhereExpression does not contain the location of
 * the WhereCompoundOp (e.g. AND, OR), and without doing that, the following
 * transformation occurs:
 * ```
 * SELECT Id
 * FROM Contact
 * WHERE
 *   Name = 'Name'
 *   AND
 *     // Comment
 *     Name = 'Another Name'
 * ```
 * Instead, this looks better:
 * ```
 * SELECT Id
 * FROM Contact
 * WHERE
 *   Name = 'Name'
 *   // Comment
 *   AND Name = 'Another Name'
 * ```
 */
function handleWhereExpression(comment, sourceCode) {
    const { enclosingNode, precedingNode, followingNode } = comment;
    if (!enclosingNode ||
        !precedingNode ||
        !followingNode ||
        !precedingNode["@class"] ||
        !followingNode["@class"] ||
        enclosingNode["@class"] !== apexTypes.WHERE_COMPOUND_EXPRESSION ||
        comment.location === undefined ||
        comment.location.startIndex === undefined) {
        return false;
    }
    if (hasNewlineInRange(sourceCode, precedingNode.loc.endIndex, comment.location.startIndex)) {
        addTrailingComment(precedingNode, comment);
        return true;
    }
    return false;
}
/**
 * Bring leading comment before Block Statement into the block itself:
 * ```
 * for (
 *   Contact a: [SELECT Id FROM Contact]
 *   // Trailing EOL Inline comment
 * ) {
 *   System.debug('Hello');
 * }
 * ```
 * transformed into
 * ```
 * for (Contact a: [SELECT Id FROM Contact]) {
 *   // Trailing EOL Inline Comment
 *   System.debug('Hello');
 * }
 * ```
 */
function handleBlockStatementLeadingComment(comment) {
    const { followingNode } = comment;
    if (!followingNode || followingNode["@class"] !== apexTypes.BLOCK_STATEMENT) {
        return false;
    }
    if (followingNode.stmnts.length) {
        addLeadingComment(followingNode.stmnts[0], comment);
    }
    else {
        addDanglingComment(followingNode, comment, null);
    }
    return true;
}
/**
 * In a binaryish expression, if there is an end of line comment, we want to
 * attach it to the right child expression instead of the entire binaryish
 * expression, because doing the latter can lead to unstable comments in
 * certain situations.
 */
function handleBinaryishExpressionRightChildTrailingComment(comment) {
    const { precedingNode } = comment;
    if (comment.placement !== "endOfLine" ||
        !precedingNode ||
        !(0, util_1.isBinaryish)(precedingNode)) {
        return false;
    }
    addTrailingComment(precedingNode.right, comment);
    return true;
}
/**
 * Turn the leading comment in a long method or variable chain into the preceding
 * comment of a previous node. Without doing that, we have an awkward position
 * for the . character like so:
 * ```
 * return StringBuilder()
 *   .// Test Comment
 *   append('Hello')
 *   .toString();
 * ```
 * Instead, this looks better:
 * ```
 * return StringBuilder()
 *   // Test Comment
 *   .append('Hello')
 *   .toString();
 * ```
 */
function handleLongChainComment(comment) {
    const { enclosingNode, precedingNode, followingNode } = comment;
    if (!enclosingNode ||
        !precedingNode ||
        !followingNode ||
        (enclosingNode["@class"] !== apexTypes.METHOD_CALL_EXPRESSION &&
            enclosingNode["@class"] !== apexTypes.VARIABLE_EXPRESSION)) {
        return false;
    }
    if (enclosingNode.dottedExpr &&
        enclosingNode.dottedExpr.value === precedingNode) {
        addTrailingComment(precedingNode, comment);
        return true;
    }
    return false;
}
/**
 * #383 (bug number 2) - If a prettier-ignore comment is attached to a modifier,
 * we need to bring it up a level, otherwise the only thing that's getting
 * ignored is the modifier itself, not the expression surrounding it (which is
 * more likely what the user wants).
 */
function handleModifierPrettierIgnoreComment(comment) {
    const { enclosingNode, followingNode } = comment;
    if (!isPrettierIgnore(comment) ||
        !enclosingNode ||
        !followingNode ||
        !followingNode["@class"] ||
        !followingNode["@class"].startsWith(apexTypes.MODIFIER)) {
        return false;
    }
    addLeadingComment(enclosingNode, comment);
    return true;
}
/**
 * This is called by Prettier's comment handling code, in order to handle
 * comments that are on their own line.
 *
 * @param comment The comment node.
 * @param sourceCode The entire source code.
 * @returns {boolean} Whether we have manually attached this comment to some AST
 * node. If `true` is returned, Prettier will no longer try to attach this
 * comment based on its internal heuristic.
 */
function handleOwnLineComment(comment, sourceCode) {
    return (handleDanglingComment(comment) ||
        handleBlockStatementLeadingComment(comment) ||
        handleWhereExpression(comment, sourceCode) ||
        handleModifierPrettierIgnoreComment(comment) ||
        handleLongChainComment(comment));
}
exports.handleOwnLineComment = handleOwnLineComment;
/**
 * This is called by Prettier's comment handling code, in order to handle
 * comments that have preceding text but no trailing text on a line.
 *
 * @param comment The comment node.
 * @param sourceCode The entire source code.
 * @returns {boolean} Whether we have manually attached this comment to some AST
 * node. If `true` is returned, Prettier will no longer try to attach this
 * comment based on its internal heuristic.
 */
function handleEndOfLineComment(comment, sourceCode) {
    return (handleDanglingComment(comment) ||
        handleBinaryishExpressionRightChildTrailingComment(comment) ||
        handleBlockStatementLeadingComment(comment) ||
        handleWhereExpression(comment, sourceCode) ||
        handleModifierPrettierIgnoreComment(comment) ||
        handleLongChainComment(comment));
}
exports.handleEndOfLineComment = handleEndOfLineComment;
/**
 * This is called by Prettier's comment handling code, in order to handle
 * comments that have both preceding text and trailing text on a line.
 *
 * @param comment The comment node.
 * @param sourceCode The entire source code.
 * @returns {boolean} Whether we have manually attached this comment to some AST
 * node. If `true` is returned, Prettier will no longer try to attach this
 * comment based on its internal heuristic.
 */
function handleRemainingComment(comment, sourceCode) {
    return (handleWhereExpression(comment, sourceCode) ||
        handleModifierPrettierIgnoreComment(comment) ||
        handleLongChainComment(comment));
}
exports.handleRemainingComment = handleRemainingComment;
/**
 * This is called by Prettier's comment handling code, in order to find out
 * if a node should be formatted or not.
 * @param path The FastPath object.
 * @returns {boolean} Whether the path should be formatted.
 */
function hasPrettierIgnore(path) {
    const node = path.getValue();
    return (node &&
        node.comments &&
        node.comments.length > 0 &&
        node.comments.filter(isPrettierIgnore).length > 0);
}
exports.hasPrettierIgnore = hasPrettierIgnore;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbWVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29tbWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDBGQUEwRjs7Ozs7O0FBRTFGLHdEQUFpRTtBQUVqRSxpQ0FLZ0I7QUFHaEIsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxHQUFHLGtCQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztBQUNyRSxNQUFNLEVBQ0osa0JBQWtCLEVBQ2xCLGlCQUFpQixFQUNqQixrQkFBa0IsRUFDbEIsaUJBQWlCLEVBQ2pCLGNBQWMsR0FDZixHQUFHLGtCQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2xCLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUV6QyxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDO0FBRXZDOzs7R0FHRztBQUNILFNBQVMsbUJBQW1CLENBQUMsT0FBMkI7SUFDdEQsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEMsT0FBTyxNQUFNLENBQUM7UUFDWixJQUFJLENBQ0YsUUFBUSxFQUNSLEtBQUssQ0FBQyxHQUFHLENBQ1AsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FDckIsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN0QixDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUM7Z0JBQ3ZCLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFO2dCQUNwQixDQUFDLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQzlCLENBQ0Y7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsU0FBZ0IsZ0JBQWdCLENBQUMsT0FBeUI7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