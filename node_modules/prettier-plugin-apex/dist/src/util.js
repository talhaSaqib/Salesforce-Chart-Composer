"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSerializerBinDirectory = exports.getPrecedence = exports.findNextUncommentedCharacter = exports.massageAstNode = exports.checkIfParentIsDottedExpression = exports.isApexDocComment = exports.isBinaryish = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const constants_1 = require("./constants");
function isBinaryish(node) {
    return (node["@class"] === constants_1.APEX_TYPES.BOOLEAN_EXPRESSION ||
        node["@class"] === constants_1.APEX_TYPES.BINARY_EXPRESSION);
}
exports.isBinaryish = isBinaryish;
/**
 * Check if this comment is an ApexDoc-style comment.
 * This code is straight from prettier JSDoc detection.
 * @param comment the comment to check.
 */
function isApexDocComment(comment) {
    const lines = comment.value.split("\n");
    return (lines.length > 1 &&
        lines
            .slice(1, lines.length - 1)
            .every((commentLine) => commentLine.trim()[0] === "*"));
}
exports.isApexDocComment = isApexDocComment;
function checkIfParentIsDottedExpression(path) {
    const node = path.getValue();
    const parentNode = path.getParentNode();
    let result = false;
    // We're making an assumption here that `callParent` is always synchronous.
    // We're doing it because FastPath does not expose other ways to find the
    // parent name.
    let parentNodeName;
    let grandParentNodeName;
    path.callParent((innerPath) => {
        parentNodeName = innerPath.getName();
    });
    path.callParent((innerPath) => {
        grandParentNodeName = innerPath.getName();
    }, 1);
    if (parentNodeName === "dottedExpr") {
        result = true;
    }
    else if (node["@class"] === constants_1.APEX_TYPES.VARIABLE_EXPRESSION &&
        parentNode["@class"] === constants_1.APEX_TYPES.ARRAY_EXPRESSION &&
        grandParentNodeName === "dottedExpr") {
        // a
        //   .b[0]  // <- Node b here
        //   .c()
        // For this situation we want to flag b as a nested dotted expression,
        // so that we can make it part of the grand parent's group, even though
        // technically it's the grandchild of the dotted expression.
        result = true;
    }
    return result;
}
exports.checkIfParentIsDottedExpression = checkIfParentIsDottedExpression;
// The metadata corresponding to these keys cannot be compared for some reason
// or another, so we will delete them before the AST comparison
const METADATA_TO_IGNORE = [
    "loc",
    "location",
    "lastNodeLoc",
    "text",
    "rawQuery",
    "@id",
    // It is impossible to preserve the comment AST. Neither recast nor
    // prettier tries to do it so we are not going to bother either.
    "comments",
    "$",
    "leading",
    "trailing",
    "hiddenTokenMap",
    "trailingEmptyLine",
    "isLastNodeInArray",
    "numberOfDottedExpressions",
    "isNextStatementOnSameLine",
    "forcedHardline",
];
/**
 * Massaging the AST node so that it can be compared. This gets called by
 * Prettier's internal code
 * @param ast the Abstract Syntax Tree to compare
 * @param newObj the newly created object
 */
function massageAstNode(ast, newObj) {
    // Handling ApexDoc
    if (ast["@class"] &&
        ast["@class"] === constants_1.APEX_TYPES.BLOCK_COMMENT &&
        isApexDocComment(ast)) {
        newObj.value = ast.value.replace(/\s/g, "");
    }
    if (ast.scope && typeof ast.scope === "string") {
        // Apex is case insensitivity, but in some case we're forcing the strings
        // to be uppercase for consistency so the ASTs may be different between
        // the original and parsed strings.
        newObj.scope = ast.scope.toUpperCase();
    }
    else if (ast.dottedExpr &&
        ast.dottedExpr.value &&
        ast.dottedExpr.value.names &&
        ast.dottedExpr.value["@class"] === constants_1.APEX_TYPES.VARIABLE_EXPRESSION &&
        ast.names) {
        // This is a workaround for #38 - jorje sometimes groups names with
        // spaces as dottedExpr, so we can't compare AST effectively.
        // In those cases we will bring the dottedExpr out into the names.
        newObj.names = newObj.dottedExpr.value.names.concat(newObj.names);
        newObj.dottedExpr = newObj.dottedExpr.value.dottedExpr;
    }
    else if (ast["@class"] &&
        ast["@class"] === constants_1.APEX_TYPES.WHERE_COMPOUND_EXPRESSION) {
        // This flattens the SOQL/SOSL Compound Expression, e.g.:
        // SELECT Id FROM Account WHERE Name = 'Name' AND (Status = 'Active' AND City = 'Boston')
        // is equivalent to:
        // SELECT Id FROM Account WHERE Name = 'Name' AND Status = 'Active' AND City = 'Boston'
        for (let i = newObj.expr.length - 1; i >= 0; i -= 1) {
            if (newObj.expr[i]["@class"] === constants_1.APEX_TYPES.WHERE_COMPOUND_EXPRESSION &&
                newObj.expr[i].op["@class"] === newObj.op["@class"]) {
                newObj.expr.splice(i, 1, ...newObj.expr[i].expr);
            }
        }
    }
    METADATA_TO_IGNORE.forEach((name) => delete newObj[name]);
}
exports.massageAstNode = massageAstNode;
/**
 * Helper function to find a character in a string, starting at an index.
 * It will ignore characters that are part of comments.
 */
function findNextUncommentedCharacter(sourceCode, character, fromIndex, commentNodes, backwards = false) {
    let indexFound = false;
    let index = -1;
    const findIndex = (comment) => comment.location &&
        comment.location.startIndex &&
        comment.location.endIndex &&
        comment.location.startIndex <= index &&
        comment.location.endIndex - 1 >= index;
    while (!indexFound) {
        if (backwards) {
            index = sourceCode.lastIndexOf(character, fromIndex);
        }
        else {
            index = sourceCode.indexOf(character, fromIndex);
        }
        indexFound = commentNodes.filter(findIndex).length === 0;
        if (backwards) {
            fromIndex = index - 1;
        }
        else {
            fromIndex = index + 1;
        }
    }
    return index;
}
exports.findNextUncommentedCharacter = findNextUncommentedCharacter;
// One big difference between our precedence list vs Prettier's core
// is that == (and its precedence equivalences) has the same precedence
// as < (and its precedence equivalences).
// e.g. a > b == c > d:
// in Javascript, this would be parsed this as: left (a > b), op (==), right (c > d)
// instead, jorje parses this as:
// left (a > b == c), op (>), right (d)
// The consequence is that formatted code does not look as nice as Prettier's core,
// but we can't change it because it will change the code's behavior.
const PRECEDENCE = {};
[
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!==", "<>", "<", ">", "<=", ">="],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
].forEach((tier, i) => {
    tier.forEach((op) => {
        PRECEDENCE[op] = i;
    });
});
function getPrecedence(op) {
    const precedence = PRECEDENCE[op];
    if (precedence === undefined) {
        throw new Error(`Failed to get precedence for operator ${op}`);
    }
    return precedence;
}
exports.getPrecedence = getPrecedence;
function doesFileExist(file) {
    try {
        (0, fs_1.accessSync)(file);
        return true;
    }
    catch (err) {
        return false;
    }
}
// The relative path to the binary can be different based on how the script
// is being run - running using ts-node vs running after code has been compiled
// to `dist` directory. We use this method to abstract out that difference.
function getSerializerBinDirectory() {
    let serializerBin = (0, path_1.join)(__dirname, "../vendor/apex-ast-serializer/bin");
    if (!doesFileExist(serializerBin)) {
        serializerBin = (0, path_1.join)(__dirname, "../../vendor/apex-ast-serializer/bin");
    }
    return serializerBin;
}
exports.getSerializerBinDirectory = getSerializerBinDirectory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLCtCQUE0QjtBQUM1QiwyQkFBZ0M7QUFHaEMsMkNBQWtFO0FBa0NsRSxTQUFnQixXQUFXLENBQUMsSUFBZ0I7SUFDMUMsT0FBTyxDQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxzQkFBUyxDQUFDLGtCQUFrQjtRQUMvQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssc0JBQVMsQ0FBQyxpQkFBaUIsQ0FDL0MsQ0FBQztBQUNKLENBQUM7QUFMRCxrQ0FLQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxPQUEyQjtJQUMxRCxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxPQUFPLENBQ0wsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDO1FBQ2hCLEtBQUs7YUFDRixLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQzFCLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUN6RCxDQUFDO0FBQ0osQ0FBQztBQVJELDRDQVFDO0FBRUQsU0FBZ0IsK0JBQStCLENBQUMsSUFBYTtJQUMzRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDN0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBRXhDLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztJQUNuQiwyRUFBMkU7SUFDM0UseUVBQXlFO0lBQ3pFLGVBQWU7SUFDZixJQUFJLGNBQWMsQ0FBQztJQUNuQixJQUFJLG1CQUFtQixDQUFDO0lBQ3hCLElBQUksQ0FBQyxVQUFV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