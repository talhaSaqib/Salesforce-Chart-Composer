"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-param-reassign: 0 */
const child_process_1 = __importStar(require("child_process"));
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
const constants_1 = require("./constants");
const MAX_BUFFER = 8192 * 8192;
function parseTextWithSpawn(text, anonymous) {
    let serializerBin = (0, util_1.getSerializerBinDirectory)();
    if (process.platform === "win32") {
        serializerBin = path_1.default.join(serializerBin, "apex-ast-serializer.bat");
    }
    else {
        serializerBin = path_1.default.join(serializerBin, "apex-ast-serializer");
    }
    const args = ["-f", "json", "-i"];
    if (anonymous) {
        args.push("-a");
    }
    const executionResult = (0, child_process_1.spawnSync)(serializerBin, args, {
        input: text,
        maxBuffer: MAX_BUFFER,
    });
    const executionError = executionResult.error;
    if (executionError) {
        throw executionError;
    }
    if (executionResult.status !== 0) {
        throw new Error(executionResult.stdout.toString());
    }
    return executionResult.stdout.toString();
}
function parseTextWithHttp(text, serverHost, serverPort, anonymous) {
    const httpClientLocation = path_1.default.join(__dirname, "http-client.js");
    const args = [
        httpClientLocation,
        "-a",
        serverHost,
        "-f",
        "json",
        "-p",
        serverPort.toString(),
    ];
    if (anonymous) {
        args.push("-n");
    }
    if (!process.argv[0]) {
        throw new Error("Failed to call http client");
    }
    const executionResult = child_process_1.default.spawnSync(process.argv[0], args, {
        input: text,
        maxBuffer: MAX_BUFFER,
    });
    if (executionResult.status) {
        const executionError = `Failed to connect to Apex parsing server\r\n${executionResult.stderr.toString()}`;
        throw new Error(executionError);
    }
    return executionResult.stdout.toString();
}
// jorje calls the location node differently for different types of nodes,
// so we use this method to abstract away that difference
function getNodeLocation(node) {
    if (node.loc) {
        return node.loc;
    }
    if (node.location) {
        return node.location;
    }
    return null;
}
// The serialized string given back contains references (to avoid circular references),
// which need to be resolved. This method recursively walks through the
// deserialized object and resolve those references.
function resolveAstReferences(node, referenceMap) {
    const nodeId = node["@id"];
    const nodeReference = node["@reference"];
    if (nodeId) {
        referenceMap[nodeId] = node;
    }
    if (nodeReference) {
        // If it has a reference attribute, that means it's a leaf node
        return referenceMap[nodeReference];
    }
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            node[key] = resolveAstReferences(node[key], referenceMap);
        }
    });
    return node;
}
function handleNodeSurroundedByCharacters(startCharacter, endCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, startCharacter, location.startIndex, commentNodes, 
        /* backwards */ true),
        endIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, endCharacter, location.startIndex, commentNodes, 
        /* backwards */ false) + 1,
    });
}
function handleNodeStartedWithCharacter(startCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, startCharacter, location.startIndex, commentNodes, 
        /* backwards */ true),
        endIndex: location.endIndex,
    });
}
function handleNodeEndedWithCharacter(endCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: location.startIndex,
        endIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, endCharacter, location.endIndex, commentNodes, 
        /* backwards */ false) + 1,
    });
}
function handleAnonymousUnitLocation(_location, sourceCode) {
    return {
        startIndex: 0,
        endIndex: sourceCode.length,
    };
}
function handleMethodDeclarationLocation(location, sourceCode, commentNodes, node) {
    // This is a method declaration with a body, so we can safely use the identity
    // location.
    if (node.stmnt.value) {
        return location;
    }
    // This is a Method Declaration with no body, in which case we need to use the
    // position of the closing parenthesis for the input parameters, e.g:
    // void method();
    return handleNodeEndedWithCharacter(")")(location, sourceCode, commentNodes);
}
function handleAnnotationLocation(location, sourceCode, commentNodes, node) {
    // This is an annotation without parameters, so we only need to worry about
    // the starting character
    if (!node.parameters || node.parameters.length === 0) {
        return handleNodeStartedWithCharacter("@")(location, sourceCode, commentNodes);
    }
    // If not, we need to use the position of the closing parenthesis after the
    // parameters as well
    return handleNodeSurroundedByCharacters("@", ")")(location, sourceCode, commentNodes);
}
// We need to generate the location for a node differently based on the node
// type. This object holds a String => Function mapping in order to do that.
const locationGenerationHandler = {};
const identityFunction = (location) => location;
// Sometimes we need to delete a location node. For example, a WhereCompoundOp
// location does not make sense since it can appear in multiple places:
// SELECT Id FROM Account
// WHERE Name = 'Name'
// AND Name = 'Other Name' // <- this AND node here
// AND Name = 'Yet Another Name' <- this AND node here
// If we keep those locations, a comment might be duplicated since it is
// attached to one WhereCompoundOp, and that operator is printed multiple times.
const removeFunction = () => null;
locationGenerationHandler[constants_1.APEX_TYPES.QUERY] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.SEARCH] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FOR_INIT] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FOR_ENHANCED_CONTROL] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.TERNARY_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_CLASS_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_INTERFACE_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_ENUM_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.IF_ELSE_BLOCK] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.NAME_VALUE_PARAMETER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.BINARY_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.BOOLEAN_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.ASSIGNMENT_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FIELD_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VALUE_WHEN] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.ELSE_WHEN] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_COMPOUND_OPERATOR] = removeFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATION_STATEMENT] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_COMPOUND_EXPRESSION] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_OPERATION_EXPRESSION] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.SELECT_INNER_QUERY] =
    handleNodeSurroundedByCharacters("(", ")");
locationGenerationHandler[constants_1.APEX_TYPES.ANONYMOUS_BLOCK_UNIT] =
    handleAnonymousUnitLocation;
locationGenerationHandler[constants_1.APEX_TYPES.NESTED_EXPRESSION] =
    handleNodeSurroundedByCharacters("(", ")");
locationGenerationHandler[constants_1.APEX_TYPES.PROPERTY_MEMBER] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.SWITCH_STATEMENT] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_LIST_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_SET_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_MAP_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_STANDARD] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATIONS] =
    handleNodeEndedWithCharacter(";");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_KEY_VALUE] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_CALL_EXPRESSION] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.ANNOTATION] = handleAnnotationLocation;
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_DECLARATION] =
    handleMethodDeclarationLocation;
/**
 * Generate and/or fix node locations, because jorje sometimes either provides
 * wrong location information or a node, or doesn't provide any information at
 * all.
 * We will fix it here by enforcing that a parent node start
 * index is always <= any child node start index, and a parent node end index
 * is always >= any child node end index.
 * @param node the node being visited.
 * @param sourceCode the entire source code.
 * @param commentNodes all the comment nodes.
 * @return the corrected node.
 */
function handleNodeLocation(node, sourceCode, commentNodes) {
    let currentLocation;
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            const location = handleNodeLocation(node[key], sourceCode, commentNodes);
            if (location && currentLocation) {
                if (currentLocation.startIndex > location.startIndex) {
                    currentLocation.startIndex = location.startIndex;
                }
                if (currentLocation.endIndex < location.endIndex) {
                    currentLocation.endIndex = location.endIndex;
                }
            }
            if (location && !currentLocation) {
                currentLocation = location;
            }
        }
    });
    const apexClass = node["@class"];
    let handlerFn;
    if (apexClass) {
        const separatorIndex = apexClass.indexOf("$");
        if (separatorIndex !== -1) {
            const parentClass = apexClass.substring(0, separatorIndex);
            if (parentClass in locationGenerationHandler) {
                handlerFn = locationGenerationHandler[parentClass];
            }
        }
        if (apexClass in locationGenerationHandler) {
            handlerFn = locationGenerationHandler[apexClass];
        }
    }
    if (handlerFn && currentLocation) {
        node.loc = handlerFn(currentLocation, sourceCode, commentNodes, node);
    }
    else if (handlerFn && node.loc) {
        node.loc = handlerFn(node.loc, sourceCode, commentNodes, node);
    }
    if (!node.loc) {
        delete node.loc;
    }
    if (node.loc && currentLocation) {
        if (node.loc.startIndex > currentLocation.startIndex) {
            node.loc.startIndex = currentLocation.startIndex;
        }
        else {
            currentLocation.startIndex = node.loc.startIndex;
        }
        if (node.loc.endIndex < currentLocation.endIndex) {
            node.loc.endIndex = currentLocation.endIndex;
        }
        else {
            currentLocation.endIndex = node.loc.endIndex;
        }
    }
    if (currentLocation) {
        return { ...currentLocation };
    }
    if (node.loc) {
        return {
            startIndex: node.loc.startIndex,
            endIndex: node.loc.endIndex,
        };
    }
    return null;
}
/**
 * Generate extra metadata (e.g. empty lines) for nodes.
 * This method is called recursively while visiting each node in the tree.
 *
 * @param node the node being visited
 * @param emptyLineLocations a list of lines that are empty in the source code
 * @param allowTrailingEmptyLine whether trailing empty line is allowed
 * for this node. This helps when dealing with statements that contain other
 * statements. For example, we turn this to `false` for the block statements
 * inside an IfElseBlock
 *
 */
function generateExtraMetadata(node, emptyLineLocations, allowTrailingEmptyLine) {
    const apexClass = node["@class"];
    let allowTrailingEmptyLineWithin;
    const isSpecialClass = constants_1.TRAILING_EMPTY_LINE_AFTER_LAST_NODE.includes(apexClass);
    const trailingEmptyLineAllowed = constants_1.ALLOW_TRAILING_EMPTY_LINE.includes(apexClass);
    if (isSpecialClass) {
        allowTrailingEmptyLineWithin = false;
    }
    else if (trailingEmptyLineAllowed) {
        allowTrailingEmptyLineWithin = true;
    }
    else {
        allowTrailingEmptyLineWithin = allowTrailingEmptyLine;
    }
    // #511 - If the user manually specify linebreaks in their original query,
    // we will use that as a heuristic to manually add hardlines to the result
    // query as well.
    if (apexClass === constants_1.APEX_TYPES.SEARCH || apexClass === constants_1.APEX_TYPES.QUERY) {
        node.forcedHardline = node.loc.startLine !== node.loc.endLine;
    }
    // jorje parses all `if` and `else if` blocks into `ifBlocks`, so we add
    // `ifBlockIndex` into the node for handling code to differentiate them.
    if (apexClass === constants_1.APEX_TYPES.IF_ELSE_BLOCK) {
        node.ifBlocks.forEach((ifBlock, index) => {
            ifBlock.ifBlockIndex = index;
        });
    }
    Object.keys(node).forEach((key) => {
        if (key === "inputParameters" && Array.isArray(node.inputParameters)) {
            node.inputParameters.forEach((inputParameter) => {
                inputParameter.insideParenthesis = true;
            });
        }
        if (typeof node[key] === "object") {
            if (Array.isArray(node)) {
                const keyInt = parseInt(key, 10);
                if (keyInt === node.length - 1) {
                    // @ts-expect-error ts-migrate(7015) FIXME: Element implicitly has an 'any' type because index... Remove this comment to see the full error message
                    node[key].isLastNodeInArray = true; // So that we don't apply trailing empty line after this node
                }
                else {
                    // Here we flag a node if its next sibling is on the same line.
                    // The reasoning is that for a block of code like this:
                    // ```
                    // Integer a = 1; Integer c = 2; Integer c = 3;
                    //
                    // Integer d = 4;
                    // ```
                    // We don't want a trailing empty line after `Integer a = 1;`
                    // so we need to mark it as a special node.
                    const currentChildNode = node[keyInt];
                    const nextChildNode = node[keyInt + 1];
                    if (nextChildNode &&
                        nextChildNode.loc &&
                        currentChildNode.loc &&
                        nextChildNode.loc.startLine === currentChildNode.loc.endLine) {
                        node[keyInt].isNextStatementOnSameLine = true;
                    }
                }
            }
            generateExtraMetadata(node[key], emptyLineLocations, allowTrailingEmptyLineWithin);
        }
    });
    const nodeLoc = getNodeLocation(node);
    if (apexClass &&
        nodeLoc &&
        allowTrailingEmptyLine &&
        !node.isLastNodeInArray &&
        !node.isNextStatementOnSameLine) {
        const nextLine = nodeLoc.endLine + 1;
        const nextEmptyLine = emptyLineLocations.indexOf(nextLine);
        if (trailingEmptyLineAllowed && nextEmptyLine !== -1) {
            node.trailingEmptyLine = true;
        }
    }
    return nodeLoc;
}
// For each node, the jorje compiler gives us its line and its index within
// that line; however we use this method to resolve that line index to a global
// index of that node within the source code. That allows us to use prettier
// utility methods.
function resolveLineIndexes(node, lineIndexes) {
    const nodeLoc = getNodeLocation(node);
    if (nodeLoc && !("startLine" in nodeLoc)) {
        // The location node that we manually generate do not contain startLine
        // information, so we will create them here.
        nodeLoc.startLine =
            lineIndexes.findIndex((index) => index > nodeLoc.startIndex) - 1;
    }
    if (nodeLoc && !("endLine" in nodeLoc)) {
        nodeLoc.endLine =
            lineIndexes.findIndex((index) => index > nodeLoc.endIndex) - 1;
        // Edge case: root node
        if (nodeLoc.endLine < 0) {
            nodeLoc.endLine = lineIndexes.length - 1;
        }
    }
    if (nodeLoc && !("column" in nodeLoc)) {
        const nodeStartLineIndex = lineIndexes[lineIndexes.findIndex((index) => index > nodeLoc.startIndex) - 1];
        if (nodeStartLineIndex !== undefined) {
            nodeLoc.column = nodeLoc.startIndex - nodeStartLineIndex;
        }
    }
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            node[key] = resolveLineIndexes(node[key], lineIndexes);
        }
    });
    return node;
}
// Get a map of line number to the index of its first character
function getLineIndexes(sourceCode) {
    // First line always start with index 0
    const lineIndexes = [0, 0];
    let characterIndex = 0;
    let lineIndex = 2;
    while (characterIndex < sourceCode.length) {
        const eolIndex = sourceCode.indexOf("\n", characterIndex);
        if (eolIndex < 0) {
            break;
        }
        lineIndexes[lineIndex] =
            lineIndexes[lineIndex - 1] +
                sourceCode.substring(characterIndex, eolIndex).length +
                1;
        characterIndex = eolIndex + 1;
        lineIndex += 1;
    }
    return lineIndexes;
}
function getEmptyLineLocations(sourceCode) {
    const whiteSpaceRegEx = /^\s*$/;
    const lines = sourceCode.split("\n");
    return lines
        .map((line) => whiteSpaceRegEx.test(line))
        .reduce((accumulator, currentValue, currentIndex) => {
        if (currentValue) {
            accumulator.push(currentIndex + 1);
        }
        return accumulator;
    }, []);
}
function parse(sourceCode, _, options) {
    const lineIndexes = getLineIndexes(sourceCode);
    let serializedAst;
    if (options.apexStandaloneParser === "built-in") {
        serializedAst = parseTextWithHttp(sourceCode, options.apexStandaloneHost, options.apexStandalonePort, options.parser === "apex-anonymous");
    }
    else {
        serializedAst = parseTextWithSpawn(sourceCode, options.parser === "apex-anonymous");
    }
    if (serializedAst) {
        let ast = JSON.parse(serializedAst);
        if (ast[constants_1.APEX_TYPES.PARSER_OUTPUT] &&
            ast[constants_1.APEX_TYPES.PARSER_OUTPUT].parseErrors.length > 0) {
            const errors = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].parseErrors.map((err) => `${err.message}.`);
            throw new Error(errors.join("\r\n"));
        }
        const commentNodes = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].hiddenTokenMap
            .map((item) => item[1])
            .filter((node) => node["@class"] === constants_1.APEX_TYPES.BLOCK_COMMENT ||
            node["@class"] === constants_1.APEX_TYPES.INLINE_COMMENT);
        ast = resolveAstReferences(ast, {});
        handleNodeLocation(ast, sourceCode, commentNodes);
        ast = resolveLineIndexes(ast, lineIndexes);
        generateExtraMetadata(ast, getEmptyLineLocations(sourceCode), true);
        ast.comments = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].hiddenTokenMap
            .map((token) => token[1])
            .filter((node) => node["@class"] === constants_1.APEX_TYPES.INLINE_COMMENT ||
            node["@class"] === constants_1.APEX_TYPES.BLOCK_COMMENT);
        return ast;
    }
    return {};
}
exports.default = parse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQWlDO0FBQ2pDLCtEQUF3RDtBQUN4RCxnREFBd0I7QUFHeEIsaUNBS2dCO0FBQ2hCLDJDQUlxQjtBQUdyQixNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBTy9CLFNBQVMsa0JBQWtCLENBQUMsSUFBWSxFQUFFLFNBQWtCO0lBQzFELElBQUksYUFBYSxHQUFHLElBQUEsZ0NBQXlCLEdBQUUsQ0FBQztJQUNoRCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQ2hDLGFBQWEsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO0tBQ3JFO1NBQU07UUFDTCxhQUFhLEdBQUcsY0FBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUscUJBQXFCLENBQUMsQ0FBQztLQUNqRTtJQUNELE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsQyxJQUFJLFNBQVMsRUFBRTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakI7SUFDRCxNQUFNLGVBQWUsR0FBRyxJQUFBLHlCQUFTLEVBQUMsYUFBYSxFQUFFLElBQUksRUFBRTtRQUNyRCxLQUFLLEVBQUUsSUFBSTtRQUNYLFNBQVMsRUFBRSxVQUFVO0tBQ3RCLENBQUMsQ0FBQztJQUVILE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUM7SUFFN0MsSUFBSSxjQUFjLEVBQUU7UUFDbEIsTUFBTSxjQUFjLENBQUM7S0FDdEI7SUFDRCxJQUFJLGVBQWUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsZUFB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