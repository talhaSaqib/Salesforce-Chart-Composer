"use strict";
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateExpressionAst = void 0;
const errors_1 = require("@lwc/errors");
const estree_walker_1 = require("estree-walker");
const t = __importStar(require("../../shared/estree"));
const ALWAYS_INVALID_TYPES = new Map(Object.entries({
    AwaitExpression: 'await expressions',
    ClassExpression: 'classes',
    FunctionExpression: 'function expressions',
    ImportExpression: 'imports',
    MetaProperty: 'import.meta',
    NewExpression: 'object instantiation',
    RegExpLiteral: 'regular expression literals',
    SequenceExpression: 'comma operators',
    Super: '`super`',
    ThisExpression: '`this`',
    YieldExpression: '`yield`',
}));
const STATEMENT_TYPES = new Set([
    'BlockStatement',
    'BreakStatement',
    'ClassDeclaration',
    'ContinueStatement',
    'DebuggerStatement',
    'DeclareClass',
    'DeclareExportAllDeclaration',
    'DeclareExportDeclaration',
    'DeclareFunction',
    'DeclareInterface',
    'DeclareModule',
    'DeclareModuleExports',
    'DeclareOpaqueType',
    'DeclareTypeAlias',
    'DeclareVariable',
    'DoWhileStatement',
    'EmptyStatement',
    'ExportAllDeclaration',
    'ExportDefaultDeclaration',
    'ExportNamedDeclaration',
    'ExpressionStatement',
    'ForInStatement',
    'ForOfStatement',
    'ForStatement',
    'FunctionDeclaration',
    'IfStatement',
    'ImportDeclaration',
    'LabeledStatement',
    'ReturnStatement',
    'Statement',
    'SwitchStatement',
    'ThrowStatement',
    'TryStatement',
    'VariableDeclaration',
    'WhileStatement',
    'WithStatement',
]);
const MUTATION_TYPES = new Set(['AssignmentExpression', 'UpdateExpression']);
function validateArrowFunction(node) {
    (0, errors_1.invariant)(node.body.type !== 'BlockStatement', errors_1.ParserDiagnostics.INVALID_EXPR_ARROW_FN_BODY);
    (0, errors_1.invariant)(!node.async, errors_1.ParserDiagnostics.INVALID_EXPR_ARROW_FN_KIND, ['async']);
    // This condition should never occur, unless the spec changes. However, it is
    // permitted by the ESTree representation, so we'll check for it just in case.
    (0, errors_1.invariant)(!node.generator, errors_1.ParserDiagnostics.INVALID_EXPR_ARROW_FN_KIND, ['generators']);
}
function validateUnaryExpression(node) {
    (0, errors_1.invariant)(node.operator !== 'delete', errors_1.ParserDiagnostics.INVALID_EXPR_DELETE_OP);
}
function validateLiteral(node) {
    // Because there may be a need for a polyfill in older browsers, and because there
    // isn't an obvious need for their inclusion, big ints are disallowed in template
    // expressions.
    (0, errors_1.invariant)(node.bigint === undefined, errors_1.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, ['BigInts']);
    // Regular expression literals are difficult to visually parse, and
    // may be difficult to programatically parse with future parsing methods. For those
    // reasons, they are also disallowed.
    (0, errors_1.invariant)(node.regex === undefined, errors_1.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, ['regular expression literals']);
}
function validateNode(node, _parent, isWithinArrowFn) {
    var _a, _b;
    (0, errors_1.invariant)(!((_a = node.leadingComments) === null || _a === void 0 ? void 0 : _a.length) && !((_b = node.trailingComments) === null || _b === void 0 ? void 0 : _b.length), errors_1.ParserDiagnostics.INVALID_EXPR_COMMENTS_DISALLOWED);
    (0, errors_1.invariant)(!STATEMENT_TYPES.has(node.type), errors_1.ParserDiagnostics.INVALID_EXPR_STATEMENTS_PROHIBITED);
    (0, errors_1.invariant)(!(MUTATION_TYPES.has(node.type) && !isWithinArrowFn), errors_1.ParserDiagnostics.INVALID_EXPR_MUTATION_OUTSIDE_ARROW);
    (0, errors_1.invariant)(!ALWAYS_INVALID_TYPES.has(node.type), errors_1.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, [ALWAYS_INVALID_TYPES.get(node.type)]);
    if (t.isArrowFunctionExpression(node)) {
        validateArrowFunction(node);
    }
    else if (t.isUnaryExpression(node)) {
        validateUnaryExpression(node);
    }
    else if (t.isLiteral(node)) {
        validateLiteral(node);
    }
}
function validateExpressionAst(rootNode) {
    let arrowFnScopeDepth = 0;
    (0, estree_walker_1.walk)(rootNode, {
        enter(node, parent) {
            validateNode(node, parent, !!arrowFnScopeDepth);
            if (t.isArrowFunctionExpression(node)) {
                arrowFnScopeDepth++;
            }
        },
        leave(node) {
            if (t.isArrowFunctionExpression(node)) {
                arrowFnScopeDepth--;
            }
        },
    });
}
exports.validateExpressionAst = validateExpressionAst;
//# sourceMappingURL=validate.js.map