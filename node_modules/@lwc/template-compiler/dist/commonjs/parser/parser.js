"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const errors_1 = require("@lwc/errors");
const ast_1 = require("../shared/ast");
const types_1 = require("../shared/types");
const constants_1 = require("./constants");
function normalizeLocation(location) {
    let line = 0;
    let column = 0;
    let length = 0;
    let start = 0;
    if (location) {
        line = location.startLine;
        column = location.startColumn;
        length = location.end - location.start;
        start = location.start;
    }
    return { line, column, start, length };
}
class ParserCtx {
    constructor(source, config) {
        this.warnings = [];
        this.seenIds = new Set();
        this.seenSlots = new Set();
        /**
         * This set is not aware of if-elseif-else blocks.
         */
        this.seenScopedSlots = new Set();
        /**
         * 'elementScopes' keeps track of the hierarchy of ParentNodes as the parser
         * traverses the parse5 AST. Each 'elementScope' is an array where each node in
         * the array corresponds to either an IfBlock, ElseifBlock, ElseBlock, ForEach, ForOf, If, Element, Component, or Slot.
         *
         * Currently, each elementScope has a hierarchy of IfBlock > ForBlock > If > Element | Component | Slot.
         * Note: Not all elementScopes will have all the nodes listed above, but when they do, they will appear in this order.
         * We do not keep track of template nodes.
         *
         * Each scope corresponds to the original parse5.Element node.
         */
        this.elementScopes = [];
        /**
         * 'siblingScopes' keeps track of the context from one sibling node to another.
         * This holds the info needed to properly parse lwc:if, lwc:elseif, and lwc:else directives.
         */
        this.siblingScopes = [];
        this.source = source;
        this.config = config;
        this.renderMode = types_1.LWCDirectiveRenderMode.shadow;
        this.preserveComments = config.preserveHtmlComments;
        // TODO [#3370]: remove experimental template expression flag
        if (config.experimentalComplexExpressions) {
            this.preparsedJsExpressions = new Map();
        }
        this.ecmaVersion = config.experimentalComplexExpressions
            ? constants_1.TMPL_EXPR_ECMASCRIPT_EDITION
            : 2020;
    }
    getSource(start, end) {
        return this.source.slice(start, end);
    }
    setRootDirective(root) {
        var _a, _b, _c;
        this.renderMode =
            (_b = (_a = root.directives.find(ast_1.isRenderModeDirective)) === null || _a === void 0 ? void 0 : _a.value.value) !== null && _b !== void 0 ? _b : this.renderMode;
        this.preserveComments =
            ((_c = root.directives.find(ast_1.isPreserveCommentsDirective)) === null || _c === void 0 ? void 0 : _c.value.value) || this.preserveComments;
    }
    /**
     * This method flattens the scopes into a single array for traversal.
     */
    *ancestors(element) {
        const ancestors = this.elementScopes.flat();
        const start = element ? ancestors.indexOf(element) : ancestors.length - 1;
        for (let i = start; i >= 0; i--) {
            yield { current: ancestors[i], parent: ancestors[i - 1] };
        }
    }
    /**
     * This method returns an iterator over ancestor nodes, starting at the parent and ending at the root node.
     *
     * Note: There are instances when we want to terminate the traversal early, such as searching for a ForBlock parent.
     *
     * @param {ParentNode} startNode - Starting node to begin search, defaults to the tail of the current scope.
     * @param {function} predicate - This callback is called once for each ancestor until it finds one where predicate returns true.
     * @param {function} traversalCond - This callback is called after predicate and will terminate the traversal if it returns false.
     * traversalCond is ignored if no value is provided.
     */
    findAncestor(predicate, traversalCond = () => true, startNode) {
        for (const { current, parent } of this.ancestors(startNode)) {
            if (predicate(current)) {
                return current;
            }
            if (!traversalCond({ current, parent })) {
                break;
            }
        }
        return null;
    }
    /**
     * This method searchs the current scope and returns the value that satisfies the predicate.
     *
     * @param {function} predicate - This callback is called once for each sibling in the current scope
     * until it finds one where predicate returns true.
     */
    findInCurrentElementScope(predicate) {
        const currentScope = this.currentElementScope() || [];
        return currentScope.find(predicate) || null;
    }
    beginElementScope() {
        this.elementScopes.push([]);
    }
    endElementScope() {
        const scope = this.elementScopes.pop();
        return scope ? scope[0] : undefined;
    }
    addNodeCurrentElementScope(node) {
        const currentScope = this.currentElementScope();
        /* istanbul ignore if */
        if (!currentScope) {
            throw new Error("Can't invoke addNodeCurrentElementScope if there is no current scope");
        }
        currentScope.push(node);
    }
    hasSeenSlot(name) {
        return this.seenSlotsFromAncestorIfTree().has(name);
    }
    addSeenSlot(name) {
        const currentSeenSlots = this.seenSlotsFromAncestorIfTree();
        if (currentSeenSlots) {
            currentSeenSlots.add(name);
        }
        else {
            this.seenSlots.add(name);
        }
    }
    currentElementScope() {
        return this.elementScopes[this.elementScopes.length - 1];
    }
    beginSiblingScope() {
        this.siblingScopes.push({
            ancestorIfContext: this.currentIfContext() || this.ancestorIfContext(),
        });
    }
    endSiblingScope() {
        this.siblingScopes.pop();
    }
    beginIfChain(node) {
        const currentSiblingContext = this.currentSiblingContext();
        if (!currentSiblingContext) {
            throw new Error('Cannot invoke beginIfChain if there is currently no sibling context');
        }
        const currentIfContext = this.currentIfContext();
        if (currentIfContext) {
            throw new Error('Should not invoke beginIfChain if an if context already exists. First end the current chain before starting a new one.');
        }
        const previouslySeenSlots = this.seenSlotsFromAncestorIfTree();
        currentSiblingContext.ifContext = {
            currentNode: node,
            seenSlots: [new Set(previouslySeenSlots)],
        };
    }
    appendToIfChain(node) {
        const currentIfContext = this.currentIfContext();
        if (!currentIfContext) {
            throw new Error('Cannot invoke appendToIfChain without first setting the if context.');
        }
        currentIfContext.currentNode = node;
        const previouslySeenSlots = this.seenSlotsFromAncestorIfTree();
        currentIfContext.seenSlots.push(new Set(previouslySeenSlots));
    }
    endIfChain() {
        const currentIfContext = this.currentIfContext();
        if (!currentIfContext) {
            throw new Error('Cannot invoke endIfChain if there is currently no if context');
        }
        // Merge seen slot names from the current if chain into the parent scope.
        const seenSlotsInAncestorIfTree = this.seenSlotsFromAncestorIfTree();
        for (const seenSlots of currentIfContext.seenSlots) {
            for (const name of seenSlots) {
                seenSlotsInAncestorIfTree.add(name);
            }
        }
        const currentSiblingContext = this.currentSiblingContext();
        if (currentSiblingContext) {
            currentSiblingContext.ifContext = undefined;
        }
    }
    getSiblingIfNode() {
        var _a;
        return (_a = this.currentIfContext()) === null || _a === void 0 ? void 0 : _a.currentNode;
    }
    isParsingSiblingIfBlock() {
        return !!this.currentIfContext();
    }
    currentSiblingContext() {
        return this.siblingScopes[this.siblingScopes.length - 1];
    }
    currentIfContext() {
        var _a;
        return (_a = this.currentSiblingContext()) === null || _a === void 0 ? void 0 : _a.ifContext;
    }
    ancestorIfContext() {
        var _a;
        return (_a = this.currentSiblingContext()) === null || _a === void 0 ? void 0 : _a.ancestorIfContext;
    }
    seenSlotsFromAncestorIfTree() {
        const ancestorIfContext = this.ancestorIfContext();
        if (ancestorIfContext) {
            return ancestorIfContext.seenSlots[ancestorIfContext.seenSlots.length - 1];
        }
        return this.seenSlots;
    }
    /**
     * This method recovers from diagnostic errors that are encountered when fn is invoked.
     * All other errors are considered compiler errors and can not be recovered from.
     *
     * @param fn - method to be invoked.
     */
    withErrorRecovery(fn) {
        try {
            return fn();
        }
        catch (error) {
            /* istanbul ignore else */
            if (error instanceof errors_1.CompilerError) {
                // Diagnostic error
                this.addDiagnostic(error.toDiagnostic());
            }
            else {
                // Compiler error
                throw error;
            }
        }
    }
    withErrorWrapping(fn, errorInfo, location, msgFormatter) {
        try {
            return fn();
        }
        catch (error) {
            if (msgFormatter) {
                error.message = msgFormatter(error);
            }
            this.throwOnError(errorInfo, error, location);
        }
    }
    throwOnError(errorInfo, error, location) {
        const diagnostic = (0, errors_1.normalizeToDiagnostic)(errorInfo, error, {
            location: normalizeLocation(location),
        });
        throw errors_1.CompilerError.from(diagnostic);
    }
    /**
     * This method throws a diagnostic error with the node's location.
     */
    throwOnNode(errorInfo, node, messageArgs) {
        this.throw(errorInfo, messageArgs, node.location);
    }
    /**
     * This method throws a diagnostic error with location information.
     */
    throwAtLocation(errorInfo, location, messageArgs) {
        this.throw(errorInfo, messageArgs, location);
    }
    /**
     * This method throws a diagnostic error and will immediately exit the current routine.
     */
    throw(errorInfo, messageArgs, location) {
        throw (0, errors_1.generateCompilerError)(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        });
    }
    /**
     * This method logs a diagnostic warning with the node's location.
     */
    warnOnNode(errorInfo, node, messageArgs) {
        this.warn(errorInfo, messageArgs, node.location);
    }
    /**
     * This method logs a diagnostic warning with location information.
     */
    warnAtLocation(errorInfo, location, messageArgs) {
        this.warn(errorInfo, messageArgs, location);
    }
    /**
     * This method logs a diagnostic warning and will continue execution of the current routine.
     */
    warn(errorInfo, messageArgs, location) {
        this.addDiagnostic((0, errors_1.generateCompilerDiagnostic)(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        }));
    }
    addDiagnostic(diagnostic) {
        this.warnings.push(diagnostic);
    }
}
exports.default = ParserCtx;
//# sourceMappingURL=parser.js.map